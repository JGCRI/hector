/* Hector -- A Simple Climate Model
   Copyright (C) 2014-2015  Battelle Memorial Institute

   Please see the accompanying file LICENSE.md for additional licensing
   information.
*/
/*
 *  ini_to_core_reader.cpp
 *  hector
 *
 *  Created by Pralit Patel on 11/1/10.
 *
 */

#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string/predicate.hpp>
#include <boost/algorithm/string/trim.hpp>

// ANS: If using the R package, use Rcpp to call R's file processing
// functions. Otherwise (e.g. if building standalone Hector), fall
// back to boost::filesystem (which needs to be installed).
#ifdef USE_RCPP
#include <Rcpp.h>
#else
#include <boost/filesystem.hpp>
namespace fs = boost::filesystem;
#endif

#include "core.hpp"
#include "message_data.hpp"
#include "ini_to_core_reader.hpp"
#include "ini.h"
#include "csv_table_reader.hpp"

namespace Hector {
  
using namespace std;

//------------------------------------------------------------------------------
/*! \brief Constructor
 *
 *  Sets a pointer to the Core object which will handle routing read in data to
 *  the correct setData
 */
INIToCoreReader::INIToCoreReader( Core* core ):core( core )
{
}

//------------------------------------------------------------------------------
/*! \brief Destructor
 *  Does not delete core since its memory is managed elsewhere.
 */
INIToCoreReader::~INIToCoreReader() {
}

//------------------------------------------------------------------------------
/*! \brief Parse and INI file at the given name filename and route the data through
 *         the core.
 *  \param filename The INI file to be parsed by the core.
 *  \exception h_exception If either there was an error reading the INI file or
 *                         or there was a problem in the Core trying to set the
 *                         data.
 */
void INIToCoreReader::parse( const string& filename ) throw ( h_exception ) {
    iniFilePath = filename;
    int errorCode = ini_parse( filename.c_str(), valueHandler, this );
    
    // handle c errors by turning them into exceptions which can be handled later
    if( errorCode == -1 ) {
        H_THROW( "Could not open " + filename );
    } else if( errorCode != 0 ) {
        // throw the original exception caught by valueHandler
        throw valueHandlerException;
    }
}

//------------------------------------------------------------------------------
/*! \brief Private call back to bridge the c interface to the Core's interface.
 *
 *  Special cases to handle table input will be handled here and will keep the
 *  core in the dark in terms of how that data was generated.
 *
 *  \param user The instance of the parser who initiated the call back.
 *  \param section The INI section (component name, as interpreted by the core)
 *  \param name The name of the variable.
 *  \param value The value of the variable to set.
 *  \exception h_exception Any errors generated by the core while trying to setData.
 */
int INIToCoreReader::valueHandler( void* user, const char* section, const char* name,
                                  const char* value )
{
    #ifdef USE_RCPP
    // Load R functions for path management
    Rcpp::Environment base("package:base");
    Rcpp::Function normalizePath = base["normalizePath"];
    Rcpp::Function dirname = base["dirname"];
    Rcpp::Function filepath = base["file.path"];
    #endif

    static const string csvFilePrefix = "csv:";
    INIToCoreReader* reader = (INIToCoreReader*)user;
    
    H_ASSERT( reader->core, "core pointer is null!" );
    string nameStr = name;
    string valueStr = value;
    StringIter startBracket = find( nameStr.begin(), nameStr.end(), '[' );
    try {
        if( startBracket != nameStr.end() ) {
            // the variableName[2000] = 5.0 case
            StringIter endBracket = find( nameStr.begin(), nameStr.end(), ']' );
            
            // the parseTSeriesIndex method will do error checking on if the brackets
            // were found and make sense
            double valueIndex = parseTSeriesIndex( startBracket, endBracket, nameStr.end() );
            
            // substring the first part of name before the open bracket which is the
            // actual variable name the core knows about
            nameStr = string( static_cast<StringIter>( nameStr.begin() ), startBracket );
            message_data data( valueStr );
            data.date = valueIndex;
            reader->core->setData( section, nameStr, data );
        } else if( boost::starts_with( valueStr, csvFilePrefix ) ) {
            // the variableName = csv:input/table.csv case
            
            // remove the special case identifier to figure out the actual file name
            // to process
            string csvFileName( valueStr.begin() + csvFilePrefix.size(), valueStr.end() );
            #ifdef USE_RCPP
            // ANS: This is the algorithm used if Hector is compiled
	    // as an R package.
            //
	    // If the csvFileName normalizes to a real path, use that.
            // Otherwise, assume that it is pointing to a file in the
            // same directory as the INI file.
            try {
                // Second argument is "winslash", which is only used
                // on Windows machines and is ignored for Unix-based
                // systems. "\\" (single backward slash) is the
                // default. Need it here to access the third argument
                // -- mustWork -- which throws the error to be caught
                // if the path doesn't exist
                csvFileName = Rcpp::as<string>(normalizePath(csvFileName, "\\", true));
            } catch (...) {
                // Get the full path of the INI file with
                // normalizePath. Then, get just the directory using dirname.
                Rcpp::String parentPath = dirname(normalizePath(reader->iniFilePath));
                csvFileName = Rcpp::as<string>(filepath(parentPath, csvFileName));
            }
            #else
            // ANS:: Algorithm for standalone Hector. Same logic -- if
            // the given path (absolute or relative) points to a file
            // that exists, use that. Otherwise, assume that the path
            // is relative to the INI file's directory. 
            fs::path csvFilePath( csvFileName );
            if ( !fs::exists(csvFilePath) ) {
              fs::path iniFilePath( reader->iniFilePath );
              fs::path fullPath( iniFilePath.parent_path() / csvFilePath );
              csvFileName = fullPath.string();
            }
            #endif

            CSVTableReader tableReader( csvFileName );
            tableReader.process( reader->core, section, nameStr );
        } else {
            // the typical variableName = value case
            // note that this implies name is not a time series variable and the
            // index will be left as the default uninitialized constant
            message_data data( valueStr );
            reader->core->setData( section, name, data );
        }
    }
    catch(const h_exception& e) {
        // We must guard this exception, since allowing it to
        // propogate back to ini_parse is unsafe.
        // Set the caught error so that when we get back from
        // ini_parse we will have the original exception to
        // rethrow
        reader->valueHandlerException = e;
        return 0;               // Error code for ini_parse
    }
    
    return 1;
}

//------------------------------------------------------------------------------
/*! \brief Parse a single time series index from a variable name.
 *
 *  The date index is assumed to be enclosed within square brackets.  Extra white
 *  space is allowed.
 *
 *  \param startBracket A string iterator pointing the the open bracket in the
 *                      variable name.
 *  \param endBracket A string iterator pointing the the close bracket in the
 *                    variable name.
 *  \param strEnd The end of the var name string used for error checking.
 *  \return The double time series index.
 *  \exception h_exception If the start or end brackets were invalid or if the
 *                         parsed index was not a double.
 */
double INIToCoreReader::parseTSeriesIndex( const StringIter startBracket,
                                          const StringIter endBracket,
                                          const StringIter strEnd )
{
    H_ASSERT( startBracket != strEnd, "index formatting issue" );
    H_ASSERT( endBracket != strEnd, "index formatting issue" );
    H_ASSERT( startBracket < endBracket, "index formatting issue" );
    
    using namespace boost;
    
    // substring out the string in between the brackets
    string dateIndexStr( startBracket + 1, endBracket );
    try {
        // remove extra white space before converting
        trim( dateIndexStr );
        return lexical_cast<double>( dateIndexStr );
    } catch( bad_lexical_cast& castException ) {
        H_THROW( "Could not convert index to double: "+dateIndexStr+", exception: "
                +castException.what() );
    }
}

}
