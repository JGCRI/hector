---
title: Adding a new component
---
Here are the steps to create a new component `X`.

Step one:
-----------

Add two new files: 

* `inst/include/X.hpp`
* `src/core/X.cpp`

It is best to copy and modify the corresponding files from an already constructed component.

Step two (within X.hpp):  
-----------

Under `private` list the variables that are used in the component and their corresponding type. Because of Hector's ability to [reset](https://jgcri.github.io/hector/reference/reset.html), every state variable generally needs an associated time series history variable.
E.g. 

* `tseries<unitval> x` to create a [time series](https://jgcri.github.io/hector/articles/manual/TimeSeries.html).
* `unitval x` to declare a [value with associated units](Unitvals.html).
* `double x` 

Step three (within X.cpp):
---------

Make sure that you `#include X.hpp`.

In the _constructor_  

If the variable is a `tseries`, add all of the variables allowing for interpolation and their corresponding names

```
	XComponent::XComponent() {
	    X_emissions.allowInterp( true ); 
	    X_emissions.name = X_COMPONENT_NAME; 
```

Within _X::init_  

Inform the core what data the component can provide (*registerCapability*) and what data the component depends on (*registerDependency*)

```
	core->registerCapability( D_ATMOSPHERIC_X, getComponentName() );
	core->registerDependency( D_LIFETIME_X, getComponentName() );
```

Within _X::setData_  

Set the data that are used as inputs within this component, typically coming from the INI file.  
For examples of `tseries` vs. `unitvals` in [Time Series](https://jgcri.github.io/hector/articles/manual/TimeSeries.html).

Within _X::prepareToRun_

This code can vary but this can be where hard coded parameters are coded. 

Within _X::run_

The run method contains the equations and code used in this component. Here is where you would want a log statement, written out to the component's log.

```
H_LOG( logger, Logger::DEBUG ) << "Year " << runToDate << " X concentration = " << X.get( runToDate ) << std::endl;
```

Within _X::getData_  

These are data that the component can provide to another component, or the data that is being generated within the component. [[For examples of tseries vs. unitvals in getData|AddTSeries]].

Within _X::shutDown_  

```
H_LOG( logger, Logger::DEBUG ) << "goodbye " << getComponentName() << std::endl;
logger.close();
```
    
Step four (Outside of X.cpp and X.hpp):
----------------------------------------

In _avistor.hpp_   

Add class `XComponent` under the declarations of subclasses and add `virtual void visit( XComponent*c ) {}`

In _core.cpp_ 

Add `#include "xcomponent.hpp" `  

Under `Core::init()` section add

```
temp =  new XComponent();
modelComponents[ temp-->getComponentName() ] = temp;
```

In _component_names.hpp_  

Under component names:   

`#define X_COMPONENT_NAME “x”`
	
In _component_data.hpp_ 

Define the variables within the component, this is  the string that will be passed into the core via 
`sendMessage` or via the R wrapper. 

`#define D_ATMOSPHERIC_X      "X"`

In _csv_outputstream_visitor.cpp_  

`#include 'xcomponent.hpp' ` 

```         
void CSVOutputStreamVisitor::visit( XComponent* c ) {
   	if( !core->outputEnabled( c->getComponentName() ) && !in_spinup ) return;
	STREAM_MESSAGE_DATE( csvFile, c, D_X_COMPONENT, current_date );
	}
```

In _csv_outputsream_visitor.hpp_ 

```
	under public  
	`virtual void visit( XComponent* c);`
```
